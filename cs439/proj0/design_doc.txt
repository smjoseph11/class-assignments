################
YOUR INFO
################
Name1: Max Timkovich
EID1: mt25825
CS login: mtimkvch
Email: mtimkvch@cs.utexas.edu
Unique Number: 53895

Slip days used:

****EACH student submits a (unique) design document.****

################
YOUR PARTNER'S INFO
################
Name1: Noah Gregg
EID1: nbg322
CS login: khrimson
Email: blaster.rifle@gmail.com
Unique Number: 53895

Your partner's ranking (scale below): Excellent

################
PARTNER EVALUATION SCALE
################
Excellent: Consistently went above and beyond - tutored others, carried
more than his/her fair share of the load.

Very Good: Consistently did what he/she was supposed to do, very well
prepared and cooperative.

Satisfactory: Usually did what he/she was supposed to do, minimally
prepared and cooperative.

Marginal: Sometimes failed to show up, rarely prepared.

Deficient: Often failed to show up, rarely prepared.

Unsatisfactory: Consistently failed to show up, unprepared.

Superficial: Practically no participation.

No Show: No participation at all.

################
Preliminaries
################
(1) If you have any preliminary comments on your submission, notes for
  the TAs, or extra credit, please give them here.

(2) Please cite any offline or online sources you consulted while
  preparing your submission, other than the Linux documentation,
  course text, and lecture notes.


################
Questions regarding Part 0
################
(1) How many child processes are created when doFib() begins with
  an input of 5?  Show the return value for each child process, numbering
  the processes beginning with 0 (the original process) and incrementing for
  each child process.

  14 child processes
  
  0. 5
  1. 3
  2. 2
  3. 1
  4. 0
  5. 1
  6. 1
  7. 1
  8. 1
  9. 0
  10. 2
  11. 1
  12. 1
  13. 0
  14. 1

(2) In part 0.3, which flavor of exec did you choose to use?  Why?

	We used execve because it takes the path as its first argument, and we also wanted to pass in the environment variable to the running program.

################
Questions regarding Part 1
################
(1) In the provided utility function Signal(), what does the call to
  sigaction() do?  Why was sigaction() used instead of signal()?

  Signal() is a wrapper function for sigaction(). It's purpose is to have its arguments be more similar to the normal signal() function but that passes in the extra arguments for sigaction(). Sigaction() is more portable than signal().
  

(2) What is the last assembly language instruction executed by the
  signal handler function that you write?

  retq

(3) After the instruction identified in the previous question executes, 
  what is the next assembly language instruction executed?

  mov $0xf,%rax

(4) When the signal handler finishes running, it must restore all of
  the registers from the interrupted thread to exactly their values
  before the signal occurred. How is this done?

  mov $0xf,%rax
  syscall
  nopl 0x0(%rax)

  On a conceptual level, it pops the register values from the exception stack with the 'syscall' command.

################
Questions regarding Part 2
################
(1) In msh.c, we use three separate signal handlers to catch our signals. 
  You can also use a single signal handler to catch all three signals.  Is
  there a design advantage of one over the other?  Explain your answer.

  No, there isn't any design advantage of one over the other. I prefer multiple functions because it feels cleaner to me. However, the signal handler could all be in one function, it just needs to have an if (or switch) statement to handle each different signal.

